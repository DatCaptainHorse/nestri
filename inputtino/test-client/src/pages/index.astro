---

---

<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <meta name="generator" content={Astro.generator}/>
    <title>Nestri input WS test client</title>
</head>
<body>
<button id="connect-button">Connect</button>
<canvas id="input-canvas" width="1280" height="720"></canvas>
</body>
</html>

<style>
    body {
        display: flex;
        flex-direction: column;
        background-color: rgb(50, 50, 50);
        padding: 1rem;
    }

    #input-canvas {
        background-color: rgb(30, 30, 30);
        outline: darkred 2px solid;
    }
</style>

<script>
  import {WS_AUTH_SECRET, WS_PORT} from "astro:env/client"

  const keyToVirtualKeyCodeMap = new Map([
    // ASCII
    ['KeyA', 0x41], ['KeyB', 0x42], ['KeyC', 0x43], ['KeyD', 0x44], ['KeyE', 0x45],
    ['KeyF', 0x46], ['KeyG', 0x47], ['KeyH', 0x48], ['KeyI', 0x49], ['KeyJ', 0x4A],
    ['KeyK', 0x4B], ['KeyL', 0x4C], ['KeyM', 0x4D], ['KeyN', 0x4E], ['KeyO', 0x4F],
    ['KeyP', 0x50], ['KeyQ', 0x51], ['KeyR', 0x52], ['KeyS', 0x53], ['KeyT', 0x54],
    ['KeyU', 0x55], ['KeyV', 0x56], ['KeyW', 0x57], ['KeyX', 0x58], ['KeyY', 0x59],
    ['KeyZ', 0x5A],

    // Digits
    ['Digit0', 0x30], ['Digit1', 0x31], ['Digit2', 0x32], ['Digit3', 0x33], ['Digit4', 0x34],
    ['Digit5', 0x35], ['Digit6', 0x36], ['Digit7', 0x37], ['Digit8', 0x38], ['Digit9', 0x39],

    // Special
    ['Escape', 0x1B],
    ['Backspace', 0x08],
    ['Tab', 0x09],
    ['Enter', 0x0D],
    ['ShiftLeft', 0xA0],
    ['ShiftRight', 0xA1],
    ['ControlLeft', 0xA2],
    ['ControlRight', 0xA3],
    ['AltLeft', 0xA4],
    ['AltRight', 0xA5],
    ['Space', 0x20],
    ['PageUp', 0x21],
    ['PageDown', 0x22],
    ['End', 0x23],
    ['Home', 0x24],
    ['ArrowLeft', 0x25],
    ['ArrowUp', 0x26],
    ['ArrowRight', 0x27],
    ['ArrowDown', 0x28],
    ['Insert', 0x2D],
    ['Delete', 0x2E],
  ]);

  function keyToVirtualKeyCode(key: string): number {
    return keyToVirtualKeyCodeMap.get(key) || 0; // Default to 0 for unknown keys
  }

  interface InputPacket_Base {
    type: string;
    sessionToken?: string;
  }

  interface InputPacket_JWTAuth extends InputPacket_Base {
    secret: string;
  }

  interface InputPacket_MouseMove extends InputPacket_Base {
    x: number;
    y: number;
    absolute: boolean;
    screenx: number;
    screeny: number;
  }

  interface InputPacket_MouseWheel extends InputPacket_Base {
    dx: number;
    dy: number;
  }

  interface InputPacket_MouseUpDown extends InputPacket_Base {
    button: number;
  }

  interface InputPacket_KeyboardUpDown extends InputPacket_Base {
    key: number;
  }

  let jwtToken: string | undefined;
  let connected = false;
  const connectButton = document.querySelector("#connect-button");
  if (connectButton) {
    connectButton.addEventListener("click", () => {
      const inputCanvas = document.getElementById("input-canvas") as HTMLCanvasElement;
      const wsClient = new WebSocket(`ws://192.168.0.7:${WS_PORT}`);

      wsClient.onopen = async function () {
        console.log("WS open");
        wsClient.send(JSON.stringify({
          type: 'jwt_session',
          secret: btoa(WS_AUTH_SECRET),
        } as InputPacket_JWTAuth));
      }
      wsClient.onmessage = function (event) {
        if (event.data) {
          console.log("WS message:", event.data);
          const parsed = JSON.parse(event.data);
          if (parsed.type === "jwt_session") {
            jwtToken = parsed.sessionToken;
            connected = true;
          }
        }
      }
      wsClient.onerror = function (event) {
        console.log("WS error:", event);
      }
      wsClient.onclose = function () {
        console.log("WS closed");
      }

      if (inputCanvas !== null) {
        inputCanvas.addEventListener("mousemove", async (ev) => {
          if (!connected) return;
          wsClient.send(JSON.stringify({
            sessionToken: jwtToken,
            type: 'input_mouse_move',
            x: ev.x,
            y: ev.y,
            absolute: true,
            screenx: inputCanvas.clientWidth,
            screeny: inputCanvas.clientHeight,
          } as InputPacket_MouseMove));
        });
        inputCanvas.addEventListener("wheel", async (ev) => {
          if (!connected) return;
          wsClient.send(JSON.stringify({
            sessionToken: jwtToken,
            type: 'input_mouse_wheel',
            dx: ev.deltaX,
            dy: ev.deltaY,
          } as InputPacket_MouseWheel));
        });
        inputCanvas.addEventListener("mouseup", async (ev) => {
          if (!connected) return;
          wsClient.send(JSON.stringify({
            sessionToken: jwtToken,
            type: 'input_mouse_up',
            button: ev.button,
          } as InputPacket_MouseUpDown));
        });
        inputCanvas.addEventListener("mousedown", async (ev) => {
          if (!connected) return;
          wsClient.send(JSON.stringify({
            sessionToken: jwtToken,
            type: 'input_mouse_down',
            button: ev.button,
          } as InputPacket_MouseUpDown));
        });
        window.addEventListener("keyup", async (ev) => {
          if (!connected) return;
          wsClient.send(JSON.stringify({
            sessionToken: jwtToken,
            type: 'input_keyboard_up',
            key: keyToVirtualKeyCode(ev.code),
          } as InputPacket_KeyboardUpDown));
        });
        window.addEventListener("keydown", async (ev) => {
          if (!connected) return;
          if (ev.repeat) {
            wsClient.send(JSON.stringify({
              sessionToken: jwtToken,
              type: 'input_keyboard_up',
              key: keyToVirtualKeyCode(ev.code),
            } as InputPacket_KeyboardUpDown));
          }
          wsClient.send(JSON.stringify({
            sessionToken: jwtToken,
            type: 'input_keyboard_down',
            key: keyToVirtualKeyCode(ev.code),
          } as InputPacket_KeyboardUpDown));
        });
      }
    });
  }
</script>
